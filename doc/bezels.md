# How MAME bezels / overlays work

Samples are using [OrionsAngel overlays](https://forums.libretro.com/t/my-realistic-arcade-bezels/10604/). Others can be more complex, with switches, LCD displays, moving elements, etc.

A MAME overlay is composed of a `.lay` file, which describes how the game should be displayed, and images overlayed on top or below the game.  
They can be completed with a `.cfg` file, which adjusts the game display.

## LAY files

Example of a bare-bone LAY file:

````xml
<mamelayout version="2">
  <element name="foo">
    <image file="foobar_overlay.png" />
  </element>
  <view name="FooBar">
    <bezel element="foo">
      <bounds x="0" y="0" width="1280" height="720" />
    </bezel>
    <screen index="0">
      <bounds x="232" y="54" width="816" height="612" />
    </screen> 
  </view>
</mamelayout>
````

- The `view` element defines an entry in the menu, here named "FooBar": to list the views, use the TAB keyboard key in a game, then select "video options".
- I assume the `bezel` coordinates and size more or less define the target screen resolution, but this element is not documented, so good luck figuring it out.
- The `screen` element defines the position of the emulated machine screen.

So far, pretty simple.

[Full documentation](https://docs.mamedev.org/techspecs/layout_files.html), although "full" is a stretch.

Nested elements are relative to their parents:

> Views, groups and elements all have their own internal coordinate systems. When an element or group is referenced from a view or another group, its coordinates are scaled as necessary to fit the specified bounds.

Thankfully OrionsAngel's bezels don't have children.

## CFG files

This file is generated when you open a game in MAME, press the TAB key > sliders > and change values; it can be generated by other actions but that's what's important here.

No documentation exists whatsoever, have fun.

````xml
<screen index="0" hoffset="-0.022000" hstretch="0.530000" voffset="0.072000" vstretch="0.560000" />
````

What I found out after fiddling with values in MAME:

- **STRETCH** is a value between 0.5 & 1.5
  - 1.0 = full screen image in its original aspect ratio, generally 4/3 (that's important for the rest)
  - 0.5 = image size / 2
  - 1.5 = image size * 2
  - resizes the image **FROM THE CENTER**: the corners move, not the center
- **OFFSET** is a value between -0.5 & 0.5 
  - 0/0 is a centered image
  - (-)0.5 = the **center** of the image is at the edge of the original screen area
  - it's defined **FROM THE CENTER OF THE SCREEN** (but applying the offset to any pixel works fine)
  - it's **RELATIVE TO THE ORIGINAL SCREEN SIZE** defined in the LAY file

## Math for conversion

Using a bezel configured for a resolution of 1280 x 720

- source lay: (x: 232, y: 54, w: 816, h: 612)
- source offset: (x: 0.022, y: 0.072, w: 0.53, h: 0.56)
- target (measured from screenshot): around (x: 406, y: 233, w: 432, h: 343)

Steps:

- start resolution = bezel x/y/w/h (=> error/warning if x/y != 0)
- apply x/y/w/h from screen.bounds = get base screen position = (x: 232, y: 54, w: 816, h: 612)
- compute original center: cx = x + (w / 2) => (cx: 640, cy: 360)
- multiply w/h by stretch = get target screen size, centered: (w: 432, h: 343) => NEW DIMENSIONS 720p
- compute new base x/y (top/left): x = cx - (w / 2) = (x: 424, y: 188,5)
- apply offset, for a horizontal image: x = x + ((hres / w * h) * hoffset) ; y = y + (vres * voffset) = (x: 402, y: 240) => NEW POSITION 720p
- apply target resolution (x * 1920 / 1280) = (x: 603, y: 360, w: 648, h: 514) => NEW COORDINATES 1080p
